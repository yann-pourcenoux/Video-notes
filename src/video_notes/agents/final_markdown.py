"""Final markdown generator agent for creating complete markdown files.

This agent combines the generated summary with video metadata to create
a comprehensive markdown file with proper formatting and structure.
"""

from pydantic import BaseModel, Field


class MarkdownInput(BaseModel):
    """Input model for final markdown generation."""

    summary_content: str = Field(..., description="The generated summary content")
    video_title: str | None = Field(None, description="Video title from metadata")
    video_url: str | None = Field(None, description="Original video URL")
    author: str | None = Field(None, description="Video author/channel name")
    publish_date: str | None = Field(None, description="Video publication date")
    duration: str | None = Field(None, description="Video duration (formatted)")


def generate_final_markdown(
    summary_content: str,
    video_title: str | None = None,
    video_url: str | None = None,
    author: str | None = None,
    publish_date: str | None = None,
    duration: str | None = None,
) -> str:
    """Generate complete markdown file with summary and metadata.

    This agent combines the generated summary with video metadata to create
    a comprehensive, well-formatted markdown file.

    Args:
        summary_content: The generated summary content
        video_title: Video title from metadata
        video_url: Original video URL
        author: Video author/channel name
        publish_date: Video publication date
        duration: Video duration (formatted)

    Returns:
        MarkdownResult with complete markdown content and metadata
    """
    # Build markdown sections
    markdown_sections = []

    # Title section
    title = video_title or "Video Summary"
    markdown_sections.append(f"# {title}\n")

    # Metadata section
    metadata_section = _generate_metadata_section(
        video_url=video_url,
        author=author,
        publish_date=publish_date,
        duration=duration,
    )
    if metadata_section:
        markdown_sections.append(metadata_section)

    # Main summary content
    if summary_content.strip():
        # Ensure summary starts with proper heading level
        processed_summary = _process_summary_content(summary_content)
        markdown_sections.append(processed_summary)

    # Footer section
    footer_section = _generate_footer()
    if footer_section:
        markdown_sections.append(footer_section)

    # Combine all sections
    markdown_content = "\n".join(markdown_sections)

    return markdown_content


def _generate_metadata_section(
    video_url: str | None = None,
    author: str | None = None,
    publish_date: str | None = None,
    duration: str | None = None,
) -> str:
    """Generate metadata section for markdown.

    Args:
        video_url: Original video URL
        author: Video author/channel name
        publish_date: Video publication date
        duration: Video duration (formatted)

    Returns:
        Formatted metadata section
    """
    metadata_lines = ["## Video Information\n"]

    # Video details
    if video_url:
        metadata_lines.append(f"**Source:** {video_url}")

    if author:
        metadata_lines.append(f"**Author:** {author}")

    if publish_date:
        metadata_lines.append(f"**Published:** {publish_date}")

    if duration:
        metadata_lines.append(f"**Duration:** {duration}")

    return "\n".join(metadata_lines) + "\n"


def _generate_footer() -> str:
    """Generate footer section.

    Returns:
        Footer section content
    """
    return "\n---\n\n*Generated by Video Notes - AI-powered video transcript summarization*"


def _process_summary_content(content: str) -> str:
    """Process summary content to ensure proper formatting.

    Args:
        content: Raw summary content

    Returns:
        Processed summary content
    """
    lines = content.split("\n")
    processed_lines: list[str] = []

    for line in lines:
        # Ensure proper spacing around headers
        if line.strip().startswith("#"):
            if processed_lines and processed_lines[-1].strip():
                processed_lines.append("")  # Add blank line before header
            processed_lines.append(line)
        else:
            processed_lines.append(line)

    return "\n".join(processed_lines)
